import osimport structfrom datetime import datetimeimport numpy as npimport pandas as pdimport randomimport mplfinance as mpf#金融画图库class ReadingAndDrawing():    # root_path = 'c:\\zd_swhy\\vipdoc'    # save_path = 'C:\\Users\\binli\\JupyterNotebook\\source'    # trade_days_limit = 1000 #4 years * 250 days pre year = 1000    # draw_days = 50    # climb_ratio = 1.15    # ris_ratio = 1.30    # bck_ratio = 1.06    columns_list = [ 'Date', 'Open', 'High', 'Low', 'Close', 'Volume' ]  # 'name',    classes_list = [ 'rise', 'climb', 'drop', 'slide', 'uncertain' ]  #'uncertain_rise', 'uncertain_drop' , 'newest', 'random'    def __init__(self,                 root_path = 'c:\\zd_swhy\\vipdoc',                 save_path = 'c:\\Users\\binli\\JupyterNotebook\\source',                 trade_days_limit=1000,                 pics_limit = 2,                 draw_days=50,                 climb_ratio = 1.15,                 ris_ratio = 1.30,                 bck_ratio = 1.06,                 stocks_cnt = 200,                 is_check = False                 ):        print('__init__ ...')        self.root_path = root_path        self.save_path = save_path        self.trade_days_limit = trade_days_limit        self.pics_limit = pics_limit        self.draw_days = draw_days        self.climb_ratio = climb_ratio        self.ris_ratio = ris_ratio        self.bck_ratio = bck_ratio        self.stocks_cnt = stocks_cnt        self.is_check = is_check        # self.catalog = os.getcwd ()        self.catalog = '\\'.join(self.save_path.split('\\')[:-1])        self.idx_low = self.columns_list.index ( 'Low' )        self.idx_high = self.columns_list.index ( 'High' )        self.idx_close = self.columns_list.index ( 'Close' )        if self.is_check:            self.w = 8            self.h = 5        else:            self.w = 2.7            self.h = 2.7        # print(type(self.bck_ratio),type(self.bck_ratio))        pass    def build_source_pics(self):        print ( 'build_source_pics ...' )        for cls in self.classes_list :            self.create_portfolio ( path=self.save_path, portfolio=cls )        for file_name_with_path in self.get_files_list () :            animation = '|/-\-'            print ( (animation[ i ] for i in range ( len ( animation ) )), end='\r' )            if self.stocks_cnt:                file_name = file_name_with_path.split ( '\\' )[ -1 ].split ( '.' )[ -2 ]                dfx = self.get_one_stock_Kline_df ( file_name_with_path )                self.classification ( file_name=file_name, save_path=self.save_path, df=dfx )                self.stocks_cnt -= 1            else:                break    def savePic_newest(self):        print ( 'savePic_newest ...' )        self.create_portfolio( path=self.catalog, portfolio='newest')        for file_name_with_path in self.get_files_list () :            file_name = file_name_with_path.split ( '\\' )[ -1 ].split ( '.' )[ -2 ]            df = self.get_one_stock_Kline_df ( file_name_with_path )            # pic_name = file_name + '_' + pics            portfolio = self.catalog + '\\' + 'newest\\'            self.draw_pics ( df=df.tail(self.draw_days), pic_name=file_name, save_portfolio_abs=portfolio )    def savePic_random(self):        print ( 'savePic_random ...' )        self.create_portfolio ( path=self.catalog, portfolio='random' )        for file_name_with_path in self.get_files_list () :            file_name = file_name_with_path.split ( '\\' )[ -1 ].split ( '.' )[ -2 ]            df = self.get_one_stock_Kline_df ( file_name_with_path )            rows = df.shape[0]            if rows > self.draw_days:                rdm = int(random.uniform(self.draw_days, rows - self.draw_days))                portfolio = self.catalog + '\\' + 'random\\'                maxPrice_pre = df.iloc[rdm : rdm + 10, self.idx_high].max()                close_price = df.iloc[rdm, self.idx_close]                if maxPrice_pre - close_price > 0:                    sign = '+++'                else:                    sign = '---'                percent = round((maxPrice_pre - close_price) / close_price * 100, 1)                pic_name = file_name + '_' + sign + str(percent)                self.draw_pics ( df=df.iloc[rdm - self.draw_days:rdm], pic_name=pic_name, save_portfolio_abs=portfolio )    def classification(self, file_name,save_path, df:pd.DataFrame):        print ( 'classification ... ',end='\r' )        rows = df.shape[0]        if rows >= 2 :            maxPrice_high = df.iloc[ -2, self.idx_high ]            maxPrice_high_id = -1            minPrice_high = df.iloc[ -1, self.idx_high ]            minPrice_high_id = -2            maxPrice_low = df.iloc[ -1, self.idx_low ]            maxPrice_low_id = -1            minPrice_low = df.iloc[ -2, self.idx_low ]            minPrice_low_id = -2            i, pics_r, pics_u, pics_c, pics_d, pics_s = 3, 0, 0, 0, 0, 0 #, 0, pics_ud            # cnt_r = 0 #避免以1day的间隔连续保存多张图片, cnt_d, 0， 引入permit_uncertain 标签后 删除此变量            # set flags for rise pics numbers >= uncertain pics and >= climb pics            permit_uncertain, permit_climb = False, False            # 设置允许保存slide pics的标志位            permit_slide = False            while i < (rows - 1) :                # temp = df.iloc[ -i ]                temp_high = df.iloc[ -i, self.idx_high ]  # 向左取出一个临近交易日的最高价                temp_low = df.iloc[ -i, self.idx_low ]  # 向左取出一个临近交易日的最低价                if temp_low > maxPrice_low :  # 如果临时价高于当前最高价，则刷新最高价，最低价默认为刷新后的最高价左侧临近交易日的最低价，更新最高、最低价格和他们的ID                    maxPrice_low = temp_low                    maxPrice_low_id = -i                    minPrice_low_id = -(i + 1)                    minPrice_low = df.iloc[ minPrice_low_id, self.idx_low ]                elif temp_low < minPrice_low :  # 如果临时价低于当前最低价，则刷新最低价及其ID                    minPrice_low = temp_low                    minPrice_low_id = -i                else :  # 如果临时价介于最低价和最高价之间时                    if ((minPrice_low_id + 2) < 0) and (-1 * (minPrice_low_id - 48) <= df.shape[ 0 ]) : #满足df切片条件                        if self.is_check:                            dfs = df.iloc[ min(minPrice_low_id, maxPrice_low_id) - 50 :max(minPrice_low_id, maxPrice_low_id) ]                            # print(dfs)                            l_dfs_max = df.iloc[ min(minPrice_low_id, maxPrice_low_id) - 50 : min(minPrice_low_id, maxPrice_low_id), self.idx_low ].max()                            l_dfs_min = df.iloc[ min(minPrice_low_id, maxPrice_low_id) - 50 : min(minPrice_low_id, maxPrice_low_id), self.idx_low ].min()                            # print(l_dfs_max,l_dfs_min)                            # l_delta = l_dfs_max - l_dfs_min                        else:                            dfs = df.iloc[minPrice_low_id - 48 :minPrice_low_id + 2 ]                            l_dfs_max = dfs.iloc[:,self.idx_low].max()                            l_dfs_min = dfs.iloc[:,self.idx_low].min()                        l_delta = l_dfs_max - l_dfs_min                        # print(l_delta)                        # 如果允许保存uncertain pics，临时价高于最高价的94%，                        # 删除条件 and cnt_r >= 0 \                        if permit_uncertain \                                and temp_low > ((2 - self.bck_ratio) * maxPrice_low) \                                and pics_u < self.pics_limit\                                and abs(minPrice_low_id - maxPrice_low_id) > 25:                                self.savePic_uncertain ( save_path=save_path, file_name=file_name, pics=pics_u,                                                              df=dfs )  # drawing_pic_uncertain_rise                                pics_u += 1                                # cnt_r = -1 * self.draw_days   #引入permit_uncertain标签后，不会出现以1day间隔多次满足条件而保存多张相似图片                                permit_uncertain = False                        elif temp_low < (self.bck_ratio * minPrice_low) :  # 如果临时价低于最低价的106%                            pass                        else: #临时价介于[1.06 * min, 0.94 * max]                            if (maxPrice_low > self.ris_ratio * minPrice_low) \                                    and (temp_low < (l_dfs_min + 0.33 * l_delta)) \                                    and (pics_r < self.pics_limit):  # 如果最高价已经超过最低价30%，就跳出循环体并返回他们的ID                                # and (temp_low < (l_dfs_min + 0.95 * l_delta)) \                                # 并且，当前的最低价不应该高于最低价与1/3的两极价差之和，这是为了过滤掉当前价格正处于高位的情况                                self.savePic_rise ( save_path=save_path, file_name=file_name, pics=pics_r,                                                    df=dfs )  # drawing_pic_rise                                pics_r += 1                                # 开启许可，保存uncertain pics and climb pics                                permit_uncertain, permit_climb = True, True                            elif permit_climb \                                    and (maxPrice_low > self.climb_ratio * minPrice_low) \                                    and (temp_low < l_dfs_min + 0.5 * l_delta)\                                    and (pics_c < self.pics_limit):  # 如果最高价已经超过最低价15%，就跳出循环体并返回他们的ID                                # 并且，当前的最低价不应该高于最低价与1/2的两极价差之和，这是为了过滤掉当前价格正处于高位的情况                                self.savePic_climb ( save_path=save_path, file_name=file_name, pics=pics_c,                                                     df=dfs )  # drawing_pic_climb                                pics_c += 1                                permit_climb = False                            #else :# 否则，说明中间价格回落超过6%，放弃之前确定的最高价，继续向左搜索                            maxPrice_low = temp_low                            maxPrice_low_id = -i                            minPrice_low_id = -(i + 1)                            minPrice_low = df.iloc[ minPrice_low_id, self.idx_low ]                        # cnt_r += 1 #引入permit_uncertain标志后取消                    else:                        pass                if temp_high > maxPrice_high :  # 如果临时价高于当前最高价，则刷新最高价                    maxPrice_high = temp_high                    maxPrice_high_id = -i                elif temp_high < minPrice_high :  # 如果临时价低于当前最低价，则刷新最低价及其ID# ，最高价默认为刷新后的最低价左侧临近交易日的价格，更新最高、最低价格和他们的ID                    minPrice_high = temp_high                    minPrice_high_id = -i                    maxPrice_high_id = -(i + 1)                    maxPrice_high = df.iloc[ maxPrice_high_id, self.idx_high ]                else :  # 如果临时价介于最低价和最高价之间时                    if ((minPrice_high_id + 2) < 0) and (-1 * (minPrice_high_id - 48) <= df.shape[ 0 ]) :  # 满足df切片条件                        if self.is_check:                            dfs = df.iloc[ min(minPrice_high_id, maxPrice_high_id) - 50 :max(minPrice_high_id, maxPrice_high_id) ]                            h_dfs_max = df.iloc[ min ( minPrice_high_id, maxPrice_high_id ) - 50 : min ( minPrice_high_id, maxPrice_high_id ), self.idx_high ].max()                            h_dfs_min = df.iloc[ min ( minPrice_high_id, maxPrice_high_id ) - 50 : min ( minPrice_high_id, maxPrice_high_id ), self.idx_high ].min()                        else:                            dfs = df.iloc[minPrice_high_id - 48 :minPrice_high_id + 2 ]                            h_dfs_max = dfs.iloc[ :, self.idx_high ].max()                            h_dfs_min = dfs.iloc[ :, self.idx_high ].min()                        h_delta = h_dfs_max - h_dfs_min                        # if temp_high < (self.bck_ratio * minPrice_low) and cnt_d >= 0 and pics_ud < self.pics_limit: #如果临时价低于最低价的106%                        #     self.savePic_uncertain_drop ( save_path=save_path, file_name=file_name, pics=pics_ud,                        #                                   df=dfs )  # drawing_pic_uncertain_drop                        #     pics_ud += 1                        #     cnt_d = -50 #避免以1day的间隔连续保存多张图片                        if temp_high > ((2 - self.bck_ratio) * maxPrice_high) :  # 如果临时价高于最高价的94%                            pass                        else:   #临时价介于[1.06 * min, 0.94 * max]                            if (maxPrice_high > self.ris_ratio * minPrice_high) \                                    and (temp_low > h_dfs_min + 0.66 * h_delta) \                                    and (pics_d < self.pics_limit):  # 如果最高价已经超过最低价30%，就跳出循环体并返回他们的ID                                # 并且，当前的最低价不应该低于最低价与2/3的两极价差之和，这是为了过滤掉当前价格正处于低位的情况                                self.savePic_drop ( save_path=save_path, file_name=file_name, pics=pics_d,                                                    df=dfs )  # drawing_pic_drop                                pics_d += 1                                permit_slide = True                            elif permit_slide \                                    and (maxPrice_high > self.climb_ratio * minPrice_high) \                                    and (temp_low > h_dfs_min + 0.5 * h_delta) \                                    and (pics_s < self.pics_limit):  # 如果最高价已经超过最低价15%，就跳出循环体并返回他们的ID                                # 并且，当前的最低价不应该低于最低价与1/2的两极价差之和，这是为了过滤掉当前价格正处于低位的情况                                self.savePic_slide ( save_path=save_path, file_name=file_name, pics=pics_s,                                                     df=dfs )  # drawing_pic_slide                                pics_s += 1                                permit_slide = False                            #else :# 否则，说明中间价格回落超过6%，放弃之前确定的最高价，继续向左搜索                            minPrice_high = temp_high                            minPrice_high_id = -i                            maxPrice_high_id = -(i + 1)                            maxPrice_high = df.iloc[ maxPrice_high_id, self.idx_high ]                        # cnt_d += 1                    else :                        pass                i += 1    # [ 'rise', 'climb', 'drop', 'slide', 'uncertain_rise', 'uncertain_drop', 'newest' ]    def savePic_rise(self, save_path, file_name, pics, df):        print ( 'savePic_rise ... \r',end='\r' )        pic_name = file_name + '_' + str(pics)        portfolio = save_path + '\\' + 'rise\\'        self.draw_pics(df=df, pic_name=pic_name, save_portfolio_abs=portfolio)    def savePic_climb(self, save_path, file_name, pics, df):        print ( 'savePic_climb ... \r',end='\r' )        pic_name = file_name + '_' + str(pics)        portfolio = save_path + '\\' + 'climb\\'        self.draw_pics ( df=df, pic_name=pic_name, save_portfolio_abs=portfolio )    def savePic_drop(self, save_path, file_name, pics, df):        print ( 'savePic_drop ... \r',end='\r' )        pic_name = file_name + '_' + str(pics)        portfolio = save_path + '\\' + 'drop\\'        self.draw_pics ( df=df, pic_name=pic_name, save_portfolio_abs=portfolio )    def savePic_slide(self, save_path, file_name, pics, df):        print ( 'savePic_slide ... \r',end='\r' )        pic_name = file_name + '_' + str(pics)        portfolio = save_path + '\\' + 'slide\\'        self.draw_pics ( df=df, pic_name=pic_name, save_portfolio_abs=portfolio )    def savePic_uncertain(self, save_path, file_name, pics, df):        print ( 'savePic_uncertain ... \r',end='\r' )        pic_name = file_name + '_' + str(pics)        portfolio = save_path + '\\' + 'uncertain\\'        self.draw_pics ( df=df, pic_name=pic_name, save_portfolio_abs=portfolio )    # def savePic_uncertain_drop(self, save_path, file_name, pics, df):    #     pic_name = file_name + '_' + str(pics)    #     portfolio = save_path + '\\' + 'uncertain_drop\\'    #     self.draw_pics ( df=df, pic_name=pic_name, save_portfolio_abs=portfolio )    def draw_pics(self, df, pic_name, save_portfolio_abs):        try:            print ( 'draw_pics ... \r',end='\r' )            df.index = pd.DatetimeIndex ( df[ 'Date' ] ) #用Data列的Datatime格式数据作为索引            # save_path = "C:\\Users\\binli\\JupyterNotebook\\" + self.folder + "\\"            mpf.plot ( df,                       type='candle',                       figsize=(self.w, self.h),                       volume=True,                       mav=(5, 10, 20),                       figscale=1.0, #放大倍数                       # xrotation=15,                       # datetime_format='%Y-%m-%d',                       tight_layout=True,                       style=mpf.make_mpf_style ( base_mpf_style='nightclouds',                                                  gridstyle='',                                                  rc={'font.size' : '0'},                                                  marketcolors=mpf.make_marketcolors ( up='white',#white                                                                                       down='red',                                                                                       # edge='white',                                                                                       wick='i',                                                                                       volume={'up' : 'white',                                                                                               'down' : 'cyan'}                                                                                       )                                                  ),                       ylabel=' ',                       ylabel_lower=' ',                       show_nontrading=False,                       volume_alpha=0.5,                       volume_panel=0,                       axisoff=True,                       #              savefig=''.join(["C:\\Users\\binli\\JupyterNotebook\\pic\\",'f_',f[:8],'_',draws,'.jpg'])                       savefig=''.join ( [ save_portfolio_abs, pic_name, '.jpg' ] )                       )        except Exception as e:            # print(df)            print(f"file name = {pic_name}, Error = {e}")    def create_portfolio(self, path, portfolio):        print ( 'create_portfolio ... ',end='\r' )        if os.path.exists(path=path + '\\' + portfolio):            pass        else:            # os.mkdir(path=self.catalog + '\\' + portfolio)            os.mkdir ( path=path + '\\' + portfolio )    def get_one_stock_Kline_df(self, file):        print ( 'get_one_stock_Kline_df ... ',end='\r' )        DK_list = self.get_one_file_data_list(file=file)        df = pd.DataFrame ( data=DK_list, columns=self.columns_list ).tail ( self.trade_days_limit )        return df    def get_files_list(self):        print ( 'get_files_list ... ',end='\r' )        files_list = [ ]        for root, dirs, files in os.walk ( self.root_path ) :            if files :                for file in files :                    if file[ :4 ] == 'sh60' or file[ :4 ] == 'sz00' :                        files_list.append ( root + '\\' + file )        return files_list    def get_one_file_data_list(self, file):        print ( 'get_one_file_data_list ... ',end='\r' )        DK_list = []        with open ( file, 'rb' ) as o :  # 'rb'代表以二进制形式的字节类型读入            while (1) :                content = o.read ( 32 )                lens = content.__len__ ()                if lens >= 32 :                    dic = {}                    b_tup = struct.unpack_from ( '<IIIIIIII', content, 0 )  # fmt- <代表小端，I代表无符号int类型                    dic[ 'date' ] = '-'.join (                        [ str ( b_tup[ 0 ] )[ :4 ], str ( b_tup[ 0 ] )[ 4 :6 ], str ( b_tup[ 0 ] )[ 6 : ] ] )                    day_datetime = datetime.strptime ( dic[ 'date' ], '%Y-%m-%d' ).date ()                    # dic[ 'name' ] = str ( file.split('\\')[-1].split('.')[-2] ) # c:\zd_swhy\vipdoc\sh\lday\sh600000.day                    dic[ 'open' ] = round ( b_tup[ 1 ] / 100,                                            2 )  # '.'.join([str(b_tup[1])[:2], str(b_tup[1])[2:]])                    dic[ 'pmax' ] = round ( b_tup[ 2 ] / 100,                                            2 )  # '.'.join([str(b_tup[2])[:2], str(b_tup[2])[2:]])                    dic[ 'pmin' ] = round ( b_tup[ 3 ] / 100,                                            2 )  # '.'.join([str(b_tup[3])[:2], str(b_tup[3])[2:]])                    dic[ 'clos' ] = round ( b_tup[ 4 ] / 100,                                            2 )  # '.'.join([str(b_tup[4])[:2], str(b_tup[4])[2:]])                    #                 dic['volx'] = b_tup[5]                    dic[ 'tnov' ] = round ( float ( b_tup[ 6 ] ) / 1000000, 2 )                    #                 dic['what'] = b_tup[7]                    # [ 'date', 'code', 'name', 'open', 'max', 'min', 'close', 'turnover', 'what', 'volx' ]                    # tup = (dic[ 'date' ], dic[ 'name' ], dic[ 'open' ], dic[ 'pmax' ], dic[ 'pmin' ], dic[ 'clos' ],                    #        dic[ 'tnov' ])  # dic['code'],, dic['what'], dic['volx'])                    tup = (dic[ 'date' ], dic[ 'open' ], dic[ 'pmax' ], dic[ 'pmin' ], dic[ 'clos' ],                           dic[ 'tnov' ])  #  dic[ 'name' ],dic['code'],, dic['what'], dic['volx'])                    DK_list.append ( tup )                else :                    break        o.close ()        return DK_listclass ReadDatas():    # root_path = 'c:\\zd_swhy\\vipdoc'    # save_path = 'C:\\Users\\binli\\JupyterNotebook\\source'    # trade_days_limit = 1000 #4 years * 250 days pre year = 1000    # draw_days = 50    # climb_ratio = 1.15    # ris_ratio = 1.30    # bck_ratio = 1.06    columns_list = [ 'Open', 'High', 'Low', 'Close', 'Volume' ]  #'Date',  'name',    classes_list = [ 'rise', 'climb', 'drop', 'slide', 'uncertain' ]  #'uncertain_rise', 'uncertain_drop' , 'newest', 'random'    def __init__(self,                 root_path = 'c:\\zd_swhy\\vipdoc',                 # save_path = 'c:\\Users\\binli\\JupyterNotebook\\source',                 trade_days_limit=1000,                 pics_limit = 2,                 draw_days=50,                 climb_ratio = 1.15,                 ris_ratio = 1.30,                 bck_ratio = 1.06,                 stocks_cnt = 200                 ):        self.root_path = root_path        # self.save_path = save_path        self.trade_days_limit = trade_days_limit        self.pics_limit = pics_limit        self.draw_days = draw_days        self.climb_ratio = climb_ratio        self.ris_ratio = ris_ratio        self.bck_ratio = bck_ratio        self.stocks_cnt = stocks_cnt        # self.catalog = os.getcwd ()        # self.catalog = '\\'.join(self.save_path.split('\\')[:-1])        self.idx_low = self.columns_list.index ( 'Low' )        self.idx_high = self.columns_list.index ( 'High' )        self.idx_close = self.columns_list.index ( 'Close' )        self.data_lst = []        self.label_lst = []        # print(type(self.bck_ratio),type(self.bck_ratio))        self.animation = '|/-\\'        pass    def get_source(self):        import time        # for cls in self.classes_list :        #     self.create_portfolio ( path=self.save_path, portfolio=cls )        # cnt = 200        for file_name_with_path in self.get_files_list () :            # animation = '|/-\-'            # print ( (animation[i] for i in range(len(animation))), end='\r' )            # time.sleep(0.05)            if self.stocks_cnt:                # file_name = file_name_with_path.split ( '\\' )[ -1 ].split ( '.' )[ -2 ]                dfx = self.get_one_stock_Kline_df ( file_name_with_path )                self.classification ( df=dfx )                #转圈显示程序正在运行                i = self.stocks_cnt % 4                print ( f'\r 程序正在运行： {self.animation[ i ]}', end='' )                time.sleep ( 0.001 )                self.stocks_cnt -= 1            else:                break            # print(dfx.shape,file_name_with_path,'\n')            # print(self.data_lst[0][0],end='\n')            # print(self.label_lst,end='\n')            # datas = np.array ( self.data_lst ) / 255.0            # labels = np.array ( self.label_lst )            # np.save ( 'c:\\Users\\binli\\JupyterNotebook\\data', datas )            # np.save ( 'c:\\Users\\binli\\JupyterNotebook\\label', labels )            #            # ld = np.load('c:\\Users\\binli\\JupyterNotebook\\data.npy')            # ll = np.load('c:\\Users\\binli\\JupyterNotebook\\label.npy')            #            # print(ld.shape,'\n')            # print(ll.shape,'\n')            # os.system('pause')    # def get_newest(self):    #     self.create_portfolio( path=self.catalog, portfolio='newest')    #    #     for file_name_with_path in self.get_files_list () :    #         file_name = file_name_with_path.split ( '\\' )[ -1 ].split ( '.' )[ -2 ]    #         df = self.get_one_stock_Kline_df ( file_name_with_path )    #    #         # pic_name = file_name + '_' + pics    #         portfolio = self.catalog + '\\' + 'newest\\'    #         self.draw_pics ( df=df.tail(self.draw_days), pic_name=file_name, save_portfolio_abs=portfolio )    def get_random(self):        # self.create_portfolio ( path=self.catalog, portfolio='random' )        for file_name_with_path in self.get_files_list () :            file_name = file_name_with_path.split ( '\\' )[ -1 ].split ( '.' )[ -2 ]            df = self.get_one_stock_Kline_df ( file_name_with_path )            rows = df.shape[0]            if rows > self.draw_days:                rdm = int(random.uniform(self.draw_days, rows - self.draw_days))                portfolio = self.catalog + '\\' + 'random\\'                maxPrice_pre = df.iloc[rdm : rdm + 10, self.idx_high].max()                close_price = df.iloc[rdm, self.idx_close]                if maxPrice_pre - close_price > 0:                    sign = '+'                else:                    sign = '-'                percent = round((maxPrice_pre - close_price) / close_price * 100, 1)                pic_name = file_name + '_' + sign + str(percent)                self.draw_pics ( df=df.iloc[rdm - self.draw_days:rdm], pic_name=pic_name, save_portfolio_abs=portfolio )    def classification(self, df:pd.DataFrame):        rows = df.shape[0]        if rows >= 2 :            maxPrice_high = df.iloc[ -2, self.idx_high ]            maxPrice_high_id = -1            minPrice_high = df.iloc[ -1, self.idx_high ]            minPrice_high_id = -2            maxPrice_low = df.iloc[ -1, self.idx_low ]            maxPrice_low_id = -1            minPrice_low = df.iloc[ -2, self.idx_low ]            minPrice_low_id = -2            i, pics_r, pics_u, pics_c, pics_d, pics_s = 3, 0, 0, 0, 0, 0 #, 0, pics_ud            cnt_r = 0 #避免以1day的间隔连续保存多张图片, cnt_d, 0            while i < (rows - 1) :                # temp = df.iloc[ -i ]                temp_high = df.iloc[ -i, self.idx_high ]  # 向左取出一个临近交易日的最高价                temp_low = df.iloc[ -i, self.idx_low ]  # 向左取出一个临近交易日的最低价                if temp_low > maxPrice_low :  # 如果临时价高于当前最高价，则刷新最高价，最低价默认为刷新后的最高价左侧临近交易日的最低价，更新最高、最低价格和他们的ID                    maxPrice_low = temp_low                    maxPrice_low_id = -i                    minPrice_low_id = -(i + 1)                    minPrice_low = df.iloc[ minPrice_low_id, self.idx_low ]                elif temp_low < minPrice_low :  # 如果临时价低于当前最低价，则刷新最低价及其ID                    minPrice_low = temp_low                    minPrice_low_id = -i                else :  # 如果临时价介于最低价和最高价之间时                    if ((minPrice_low_id + 2) < 0) and (-1 * (minPrice_low_id - 48) <= df.shape[ 0 ]) : #满足df切片条件                        dfs = df.iloc[minPrice_low_id - 48 :minPrice_low_id + 2 ]                        l_dfs_max = dfs.iloc[ :, self.idx_low ].max ()                        l_dfs_min = dfs.iloc[ :, self.idx_low ].min ()                        l_delta = l_dfs_max - l_dfs_min                        if temp_low > ((2 - self.bck_ratio) * maxPrice_low) and cnt_r >= 0 and pics_u < self.pics_limit and abs(minPrice_low_id - maxPrice_low_id) > 25: #如果临时价高于最高价的94%                                self.append_uncertain (df=dfs )  # drawing_pic_uncertain_rise                                pics_u += 1                                cnt_r = -1 * self.draw_days                        elif temp_low < (self.bck_ratio * minPrice_low) :  # 如果临时价低于最低价的106%                            pass                        else: #临时价介于[1.06 * min, 0.94 * max]                            if (maxPrice_low > self.ris_ratio * minPrice_low) and (temp_low < (l_dfs_min + 0.33 * l_delta)) and (pics_r < self.pics_limit):  # 如果最高价已经超过最低价30%，就跳出循环体并返回他们的ID                                self.append_rise ( df=dfs )  # drawing_pic_rise                                pics_r += 1                            elif (maxPrice_low > self.climb_ratio * minPrice_low) and (temp_low < l_dfs_min + 0.5 * l_delta) and (pics_c < self.pics_limit):  # 如果最高价已经超过最低价15%，就跳出循环体并返回他们的ID                                self.append_climb ( df=dfs )  # drawing_pic_climb                                pics_c += 1                            #else :# 否则，说明中间价格回落超过6%，放弃之前确定的最高价，继续向左搜索                            maxPrice_low = temp_low                            maxPrice_low_id = -i                            minPrice_low_id = -(i + 1)                            minPrice_low = df.iloc[ minPrice_low_id, self.idx_low ]                        cnt_r += 1                    else:                        pass                if temp_high > maxPrice_high :  # 如果临时价高于当前最高价，则刷新最高价                    maxPrice_high = temp_high                    maxPrice_high_id = -i                elif temp_high < minPrice_high :  # 如果临时价低于当前最低价，则刷新最低价及其ID# ，最高价默认为刷新后的最低价左侧临近交易日的价格，更新最高、最低价格和他们的ID                    minPrice_high = temp_high                    minPrice_high_id = -i                    maxPrice_high_id = -(i + 1)                    maxPrice_high = df.iloc[ maxPrice_high_id, self.idx_high ]                else :  # 如果临时价介于最低价和最高价之间时                    if ((minPrice_high_id + 2) < 0) and (-1 * (minPrice_high_id - 48) <= df.shape[ 0 ]) :  # 满足df切片条件                        dfs = df.iloc[ minPrice_high_id - 48 :minPrice_high_id + 2 ]                        h_dfs_max = dfs.iloc[ :, self.idx_high ].max ()                        h_dfs_min = dfs.iloc[ :, self.idx_high ].min ()                        h_delta = h_dfs_max - h_dfs_min                        # if temp_high < (self.bck_ratio * minPrice_low) and cnt_d >= 0 and pics_ud < self.pics_limit: #如果临时价低于最低价的106%                        #     self.savePic_uncertain_drop ( save_path=save_path, file_name=file_name, pics=pics_ud,                        #                                   df=dfs )  # drawing_pic_uncertain_drop                        #     pics_ud += 1                        #     cnt_d = -50 #避免以1day的间隔连续保存多张图片                        if temp_high > ((2 - self.bck_ratio) * maxPrice_high) :  # 如果临时价高于最高价的94%                            pass                        else:   #临时价介于[1.06 * min, 0.94 * max]                            if (maxPrice_high > self.ris_ratio * minPrice_high) and (temp_low > h_dfs_min + 0.66 * h_delta) and (pics_d < self.pics_limit):  # 如果最高价已经超过最低价30%，就跳出循环体并返回他们的ID                                self.append_drop ( df=dfs )  # drawing_pic_drop                                pics_d += 1                            elif (maxPrice_high > self.climb_ratio * minPrice_high) and (temp_low > h_dfs_min + 0.5 * h_delta) and (pics_s < self.pics_limit):  # 如果最高价已经超过最低价15%，就跳出循环体并返回他们的ID                                self.append_slide ( df=dfs )  # drawing_pic_slide                                pics_s += 1                            #else :# 否则，说明中间价格回落超过6%，放弃之前确定的最高价，继续向左搜索                            minPrice_high = temp_high                            minPrice_high_id = -i                            maxPrice_high_id = -(i + 1)                            maxPrice_high = df.iloc[ maxPrice_high_id, self.idx_high ]                        # cnt_d += 1                    else :                        pass                i += 1    # [ 'rise', 'climb', 'drop', 'slide', 'uncertain_rise', 'uncertain_drop', 'newest' ]    def append_rise(self, df):        df = np.array(df)        self.data_lst.append(df)        self.label_lst.append('rise')    def append_climb(self, df):        df = np.array(df)        self.data_lst.append(df)        self.label_lst.append('climb')    def append_drop(self, df):        df = np.array(df)        self.data_lst.append(df)        self.label_lst.append('drop')    def append_slide(self, df):        df = np.array(df)        self.data_lst.append(df)        self.label_lst.append('slide')    def append_uncertain(self, df):        df = np.array(df)        self.data_lst.append(df)        self.label_lst.append('uncertain')    # def savePic_uncertain_drop(self, save_path, file_name, pics, df):    #     pic_name = file_name + '_' + str(pics)    #     portfolio = save_path + '\\' + 'uncertain_drop\\'    #     self.draw_pics ( df=df, pic_name=pic_name, save_portfolio_abs=portfolio )    def get_one_stock_Kline_df(self, file):        DK_list = self.get_one_file_data_list(file=file)        df = pd.DataFrame ( data=DK_list, columns=self.columns_list ).tail ( self.trade_days_limit )        return df    def get_files_list(self):        files_list = [ ]        for root, dirs, files in os.walk ( self.root_path ) :            if files :                for file in files :                    if file[ :4 ] == 'sh60' or file[ :4 ] == 'sz00' :                        files_list.append ( root + '\\' + file )        return files_list    # tuple = ('date', 'open', 'pmax', 'pmin', 'clos', 'tnov')    def get_one_file_data_list(self, file, *args):        is_date, is_open, is_pmax, is_pmin, is_clos, is_tnov = False, False, False, False, False, False        for arg in args:            if arg == 'date': is_date = True            elif arg == 'open': is_open = True            elif arg == 'pmax': is_pmax = True            elif arg == 'pmin': is_pmin = True            elif arg == 'clos': is_clos = True            elif arg == 'tnov': is_tnov = True            else: pass        try:            DK_list = [ ]            with open ( file, 'rb' ) as o :  # 'rb'代表以二进制形式的字节类型读入                while (1) :                    content = o.read ( 32 )                    lens = content.__len__ ()                    if lens >= 32 :                        dic = {}                        b_tup = struct.unpack_from ( '<IIIIIIII', content, 0 )  # fmt- <代表小端，I代表无符号int类型                        if is_date:                            dic[ 'date' ] = '-'.join (                                [ str ( b_tup[ 0 ] )[ :4 ], str ( b_tup[ 0 ] )[ 4 :6 ], str ( b_tup[ 0 ] )[ 6 : ] ] )                        # day_datetime = datetime.strptime ( dic[ 'date' ], '%Y-%m-%d' ).date ()                        # dic[ 'name' ] = str ( file.split('\\')[-1].split('.')[-2] ) # c:\zd_swhy\vipdoc\sh\lday\sh600000.day                        dic[ 'open' ] = round ( b_tup[ 1 ] / 100,                                                2 )  # '.'.join([str(b_tup[1])[:2], str(b_tup[1])[2:]])                        dic[ 'pmax' ] = round ( b_tup[ 2 ] / 100,                                                2 )  # '.'.join([str(b_tup[2])[:2], str(b_tup[2])[2:]])                        dic[ 'pmin' ] = round ( b_tup[ 3 ] / 100,                                                2 )  # '.'.join([str(b_tup[3])[:2], str(b_tup[3])[2:]])                        dic[ 'clos' ] = round ( b_tup[ 4 ] / 100,                                                2 )  # '.'.join([str(b_tup[4])[:2], str(b_tup[4])[2:]])                        #                 dic['volx'] = b_tup[5]                        dic[ 'tnov' ] = round ( float ( b_tup[ 6 ] ) / 1000000, 2 )                        #                 dic['what'] = b_tup[7]                        # [ 'date', 'code', 'name', 'open', 'max', 'min', 'close', 'turnover', 'what', 'volx' ]                        # tup = (dic[ 'date' ], dic[ 'name' ], dic[ 'open' ], dic[ 'pmax' ], dic[ 'pmin' ], dic[ 'clos' ],                        #        dic[ 'tnov' ])  # dic['code'],, dic['what'], dic['volx'])                        tup = (dic[ 'open' ], dic[ 'pmax' ], dic[ 'pmin' ], dic[ 'clos' ],                               dic[ 'tnov' ])  # dic[ 'date' ],  dic[ 'name' ],dic['code'],, dic['what'], dic['volx'])                        DK_list.append ( tup )                    else :                        break            o.close ()            return DK_list        except Exception as e:            print(f'Error:{e}')if __name__ == '__main__':    rd = ReadingAndDrawing(stocks_cnt=10,save_path='c:\\Users\\binli\\JupyterNotebook\\check',is_check=True)    rd.build_source_pics()    # rd.savePic_newest()    # rd.savePic_random()